{"version":3,"sources":["../src/AmqpConnectionManager.js"],"names":["HEARTBEAT_IN_SECONDS","neverThrows","err","setImmediate","Error","message","stack","AmqpConnectionManager","EventEmitter","constructor","urls","options","logger","debug","findServers","_channels","_currentUrl","connectionOptions","heartbeatIntervalInSeconds","reconnectTimeInSeconds","setMaxListeners","_findServers","Promise","resolve","_connect","createChannel","channel","ChannelWrapper","push","once","filter","c","close","_closed","all","map","catch","then","_currentConnection","removeAllListeners","isConnected","_connecting","_urls","length","pb","callFn","Array","isArray","url","urlString","amqpUrl","urlUtils","parse","search","amqp","connect","format","connection","on","reason","emit"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport amqp from 'amqplib';\nimport urlUtils from 'url';\n\nimport ChannelWrapper from './ChannelWrapper';\nimport { wait } from './helpers';\nimport pb from 'promise-breaker';\n\n// Default heartbeat time.\nconst HEARTBEAT_IN_SECONDS = 5;\n\n/* istanbul ignore next */\nfunction neverThrows() {\n    return err =>\n        setImmediate(() => {\n            throw new Error(`AmqpConnectionManager - should never get here: ${err.message}\\n` +\n                err.stack);\n        });\n}\n\n//\n// Events:\n// * `connect({connection, url})` - Emitted whenever we connect to a broker.\n// * `disconnect({err})` - Emitted whenever we disconnect from a broker.\n//\nexport default class AmqpConnectionManager extends EventEmitter {\n    /**\n     *  Create a new AmqplibConnectionManager.\n     *\n     * @param {(string|Object)[]} urls - An array of brokers to connect to.\n     *   Takes url strings or objects {url: string, connectionOptions?: object}\n     *   If present, a broker's [connectionOptions] will be used instead\n     *   of [options.connectionOptions] when passed to the amqplib connect method.\n     *   AmqplibConnectionManager will round-robin between them whenever it\n     *   needs to create a new connection.\n     * @param {Object} [options={}] -\n     * @param {number} [options.heartbeatIntervalInSeconds=5] - The interval,\n     *   in seconds, to send heartbeats.\n     * @param {number} [options.reconnectTimeInSeconds] - The time to wait\n     *   before trying to reconnect.  If not specified, defaults to\n     *   `heartbeatIntervalInSeconds`.\n     * @param {Object} [options.connectionOptions] - Passed to the amqplib\n     *   connect method.\n     * @param {function} [options.findServers] - A `fn(callback)` or a `fn()`\n     *   which returns a Promise.  This should resolve to one or more servers\n     *   to connect to, either a single URL or an array of URLs.  This is handy\n     *   when you're using a service discovery mechanism such as Consul or etcd.\n     *   Note that if this is supplied, then `urls` is ignored.\n     * @param {Object} logger - A logger interface to log errors.\n     */\n    constructor(urls, options = {}, logger = {\n        debug: () => {}\n    }) {\n        super();\n        this.logger = logger;\n        if(!urls && !options.findServers) {\n            throw new Error(\"Must supply either `urls` or `findServers`\");\n        }\n        this._channels = [];\n\n        this._currentUrl = 0;\n        this.connectionOptions = options.connectionOptions;\n\n        this.heartbeatIntervalInSeconds = options.heartbeatIntervalInSeconds || HEARTBEAT_IN_SECONDS;\n        this.reconnectTimeInSeconds = options.reconnectTimeInSeconds || this.heartbeatIntervalInSeconds;\n\n        // There will be one listener per channel, and there could be a lot of channels, so disable warnings from node.\n        this.setMaxListeners(0);\n\n        this._findServers = options.findServers || (() => Promise.resolve(urls));\n\n        this._connect();\n    }\n\n    // `options` here are any options that can be passed to ChannelWrapper.\n    createChannel(options = {}) {\n        const channel = new ChannelWrapper(this, options);\n        this._channels.push(channel);\n        channel.once('close', () => {\n            this._channels = this._channels.filter(c => c !== channel);\n        });\n        return channel;\n    }\n\n    close() {\n        if(this._closed) { return Promise.resolve(); }\n        this._closed = true;\n\n        return Promise.all(this._channels.map(channel => channel.close()))\n            .catch(function() {\n                // Ignore errors closing channels.\n            })\n            .then(() => {\n                this._channels = [];\n                if(this._currentConnection) {\n                    this._currentConnection.removeAllListeners('close');\n                    this._currentConnection.close();\n                }\n                this._currentConnection = null;\n            });\n    }\n\n    isConnected() {\n        return !!this._currentConnection;\n    }\n\n    _connect() {\n        this.logger.debug('Started _connect method');\n        if(this._closed || this._connecting || this.isConnected()) {\n            this.logger.debug(`Instantly resolving: _closed = ${this._closed}, _connecting = ${this._connecting}, \n            isConnected() = ${this.isConnected()}`);\n            return Promise.resolve();\n        }\n\n        this._connecting = true;\n        this.logger.debug('_connecting set to true');\n        return Promise.resolve()\n        .then(() => {\n            if(!this._urls || (this._currentUrl >= this._urls.length)) {\n                this._currentUrl = 0;\n                return pb.callFn(this._findServers, 0, null);\n            } else {\n                return this._urls;\n            }\n        })\n        .then(urls => {\n            if(urls && !Array.isArray(urls)) { urls = [urls]; }\n            this._urls = urls;\n\n            if(!urls || (urls.length === 0)) {\n                throw new Error('amqp-connection-manager: No servers found');\n            }\n\n            // Round robin between brokers\n            const url = urls[this._currentUrl];\n            this._currentUrl++;\n\n            // url can be a string or object {url: string, connectionOptions?: object}\n            const urlString = url.url || url;\n            const connectionOptions = url.connectionOptions || this.connectionOptions;\n\n            const amqpUrl = urlUtils.parse(urlString);\n            if(amqpUrl.search) {\n                amqpUrl.search += `&heartbeat=${this.heartbeatIntervalInSeconds}`;\n            } else {\n                amqpUrl.search = `?heartbeat=${this.heartbeatIntervalInSeconds}`;\n            }\n            this.logger.debug('Attempting to connect to rabbitMq');\n            return amqp.connect(urlUtils.format(amqpUrl), connectionOptions)\n            .then(connection => {\n                this.logger.debug(`Connection established`);\n                this._currentConnection = connection;\n\n                //emit 'blocked' when RabbitMQ server decides to block the connection (resources running low)\n                connection.on('blocked', reason => this.emit('blocked', { reason }));\n\n                connection.on('unblocked', () => this.emit('unblocked'));\n\n                connection.on('error', (err) => {\n                    // if this event was emitted, then the connection was already closed,\n                    // so no need to call #close here\n                    // also, 'close' is emitted after 'error',\n                    // so no need for work already done in 'close' handler\n                    this.logger.debug(`Connection raised error event: message - ${err.message}; stack - ${err.stack}`);\n                });\n\n                // Reconnect if the connection closes\n                connection.on('close', err => {\n                    this.logger.debug(`Connection raised close event: message - ${err.message}; stack - ${err.stack}`);\n                    this._currentConnection = null;\n                    this.logger.debug('_currentConnection set to null');\n                    this.emit('disconnect', { err });\n                    this.logger.debug(`Emitted disconnect event`);\n                    this.logger.debug(`Waiting ${this.reconnectTimeInSeconds * 1000} seconds to attempt a reconnect`);\n                    wait(this.reconnectTimeInSeconds * 1000)\n                    .then(() => {\n                        this.logger.debug(`Attempting to reconnect`);\n                        this._connect();\n                    })\n                    // `_connect()` should never throw.\n                    .catch(neverThrows);\n                });\n\n                this._connecting = false;\n                this.logger.debug(`_connecting set to false`);\n                this.emit('connect', { connection, url: urlString });\n                this.logger.debug(`Emitted connect event`);\n                return null;\n            });\n        })\n        .catch(err => {\n            this.emit('disconnect', { err });\n            this.logger.debug(`Emitted disconnect event`);\n            // Connection failed...\n            this._currentConnection = null;\n            this.logger.debug('_currentConnection set to null');\n            // TODO: Probably want to try right away here, especially if there are multiple brokers to try...\n            this.logger.debug(`Waiting ${this.reconnectTimeInSeconds * 1000} seconds to attempt a reconnect`);\n            return wait(this.reconnectTimeInSeconds * 1000)\n            .then(() => {\n                this.logger.debug(`Attempting to reconnect`);\n                this._connecting = false;\n                this.logger.debug(`_connecting set to false`);\n                return this._connect();\n            });\n        });\n    }\n}\n"],"file":"AmqpConnectionManager.js"}